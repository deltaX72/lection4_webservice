# Proxy on python
```python
    from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
    from SocketServer import ThreadingMixIn
    import urllib2, sys, re, httplib, urlparse

    class ThreadedHTTPServer( ThreadingMixIn, HTTPServer ): 
        #поток-демон уничтожается при уничтожении главного потока
        #пользовательский поток может не уничтожаться, программа висит
          daemon_threads = True 
        if __name__ == '__main__': 
          proxy = ThreadedHTTPServer( ( 'localhost', 19277 ), ProxyHandler ) 
          try: 
            proxy.serve_forever() 
          except KeyboardInterrupt: 
            print 'End of server' 
          proxy.server_close() 

    class ProxyHandler(BaseHTTPRequestHandler):
        server_version = ''
        sys_version = ''
        def do_HEAD(self):
            print "HEAD"
        def log_message(self, format, *args):
            return
```
---
```python
        def do_POST( self ): 
            print '-------------------------------' 
            print "POST" 
            requested_url = self.requestline.split()[1] 
            parsed_url = urlparse.urlsplit( requested_url ) 
            cutted_url = urlparse.urlunsplit( ( '', '', parsed_url.path, parsed_url.query, '' ) ) 
            print parsed_url.hostname 
            print parsed_url.path 
            print parsed_url.query 
            print requested_url 
            port = 80 if None == parsed_url.port else parsed_url.port 
            req_headers = {} 
            for x in self.headers.items(): 
              req_headers[x[0]] = x[1] 
            print req_headers 
            body = self.rfile.read(int(self.headers['content-length'])) 
            print 'body -- ',body 
            conn = httplib.HTTPConnection( parsed_url.hostname, port ) 
            conn.request( 'POST', cutted_url, body,headers = req_headers ) 
            response = conn.getresponse() 
            print response.status 
            self.send_response( response.status ) 
            for x in response.msg.items(): 
              self.send_header( x[0], x[1] ) 
            self.end_headers() 

            html = response.read() 
            self.wfile.write( html ) 
            self.connection.close() 
            conn.close() 
            print 'End - post' 
            return 
```
---
```python
        def do_GET( self ): 
            print '--------------------------------------' 
            print 'GET' 
            requested_url = self.requestline.split()[1] 
            parsed_url = urlparse.urlsplit( requested_url ) 
            cutted_url = urlparse.urlunsplit( ( '', '', parsed_url.path, parsed_url.query, '' ) ) 
            port = 80 if None == parsed_url.port else parsed_url.port 
            req_headers = {} 
            for x in self.headers.items(): 
              req_headers[x[0]] = x[1] 
            print req_headers 

            conn = httplib.HTTPConnection( parsed_url.hostname, port ) 
            conn.request( 'GET', cutted_url ,'' ,req_headers ) 
            response = conn.getresponse() 
            self.name = '' 
            self.send_response( response.status ) 
            print response.status 
            print parsed_url.hostname, ':', port 
            print response.msg.items() 
            i=0 
            for x in response.msg.items(): 
              i=i+1 
              if(x[0]!='transfer-encoding'): 
                print '--- ', x[0],' : ' ,x[1] 
                if(x[0]!='connection'): 
                  self.send_header( x[0], x[1] ) 
                else: self.send_header( 'connection', 'close' ) 
            self.end_headers() 
            html = response.read() 
            self.wfile.write( html ) 
            conn.close() 
            self.connection.close() 
            print 'END -- GET' 
            return 0 
```    
